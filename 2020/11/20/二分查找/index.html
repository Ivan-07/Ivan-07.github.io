<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="二分查找"><meta name="keywords" content=""><meta name="author" content="Ivan"><meta name="copyright" content="Ivan"><title>二分查找 | Ivan</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8ebeef3be59d7cabe880d5f4fd5049e7";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"YDZ9DI1M0Q","apiKey":"be2a0746731dbd3a9d7d5169ea1099c2","indexName":"index","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.1.1'
} </script><meta name="generator" content="Hexo 5.1.1"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A%E5%87%8F%E8%80%8C%E6%B2%BB%E4%B9%8B"><span class="toc-text">二分查找的基本思想：减而治之</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%8C%E5%87%8F%E8%80%8C%E6%B2%BB%E4%B9%8B%E3%80%8D%E6%80%9D%E6%83%B3%E7%AE%80%E4%BB%8B"><span class="toc-text">「减而治之」思想简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">二分查找算法的应用范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E6%95%B0%EF%BC%88%E4%BA%8C%E5%88%86%E4%B8%8B%E6%A0%87%EF%BC%89"><span class="toc-text">在有序数组中进行查找一个数（二分下标）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%95%B4%E6%95%B0%E8%8C%83%E5%9B%B4%E5%86%85%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%88%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%EF%BC%89"><span class="toc-text">在整数范围内查找一个整数（二分答案）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%80%9D%E8%B7%AF"><span class="toc-text">二分查找算法的两种思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-text">二分查找的最基本问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1"><span class="toc-text">思路1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">代码块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2"><span class="toc-text">思路2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%971"><span class="toc-text">代码块1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%972"><span class="toc-text">代码块2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">适用范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%BB%86%E8%8A%82%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">二分查找的细节（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-1%EF%BC%9A%E5%BE%AA%E7%8E%AF%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-text">细节 1：循环可以继续的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-2%EF%BC%9A%E5%8F%96%E4%B8%AD%E9%97%B4%E6%95%B0%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">细节 2：取中间数的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-3%EF%BC%9A%E5%8F%96%E4%B8%AD%E9%97%B4%E6%95%B0%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B8%8A%E5%8F%96%E6%95%B4"><span class="toc-text">细节 3：取中间数可不可以上取整</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A6%81%E7%82%B9"><span class="toc-text">编码要点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE"><span class="toc-text">经典题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E9%A2%98"><span class="toc-text">35题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E9%A2%98"><span class="toc-text">36题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#154%E9%A2%98"><span class="toc-text">154题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69%E9%A2%98"><span class="toc-text">69题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#287%E9%A2%98"><span class="toc-text">287题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Ivan</div><div class="author-info__description text-center">Stay Hungry | Stay Foolish</div><div class="follow-button"><a href="https://ivan-07.xyz/aboutMe">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/top_img.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Ivan</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/aboutMe">About me</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">二分查找</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-20</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>@(leetcode)[数组|哈希表|字符串]</p>
<p><strong>二分查找</strong>是算法题中一种非常常见的基础算法。本文主要借鉴weiwei哥的个人算法书 —— <a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/learning-algorithms-with-leetcode/xsz9zc/">链接</a></p>
<hr>
<p>[TOC]</p>
<h2 id="二分查找的基本思想：减而治之"><a href="#二分查找的基本思想：减而治之" class="headerlink" title="二分查找的基本思想：减而治之"></a>二分查找的基本思想：减而治之</h2><blockquote>
<p><strong>二分查找</strong>的思想在我们的生活和工作中很常见，<strong>二分查找</strong>通过不断缩小搜索区间的范围，直到找到目标元素或者没有找到目标元素。这里<strong>不断缩小搜索区间</strong>是一种 <em>减而治之</em> 的思想，也称为<strong>减治思想</strong>。<br><img src="https://i.loli.net/2020/11/19/JXkOWpuT9aiRsHq.png" alt="1605062779533.png"></p>
</blockquote>
<h3 id="「减而治之」思想简介"><a href="#「减而治之」思想简介" class="headerlink" title="「减而治之」思想简介"></a>「减而治之」思想简介</h3><p>这里「减」是「减少问题」规模的意思，治是「解决」的意思。「减治思想」从另一个角度说，是「排除法」，意即：每一轮排除掉一定不存在目标元素的区间，在剩下<strong>可能</strong>存在目标元素的区间里继续查找。每一次我们通过一些判断和操作，使得问题的规模逐渐减少。又由于问题的规模是有限的，我们通过有限次的操作，一定可以解决这个问题。</p>
<p>可能有的朋友听说过「分治思想」，「分治思想」与「减治思想」的差别就在于，我们把一个问题拆分成若干个子问题以后，应用「减治思想」解决的问题就只在其中一个子问题里寻找答案。「分治思想」我们在下一章会向大家介绍。</p>
<ul>
<li><p><strong>例 1</strong>：以前央视二套的《幸运 52》栏目有一个「猜价格」游戏。游戏规则是：给出一个商品，告诉答题者它的价格在多少元（价格为整数）以内，让答题者猜，如果猜出的价格低于真正价格，主持人就说少了，高于真正的价格，就说多了，看谁能在最短的时间内猜中。这个游戏就是应用减治思想完成「猜价格」任务的。主持人说「多了」或这「少了」，就是给参与游戏的人反馈，让游戏者逐渐缩小价格区间，最终猜中价格。</p>
</li>
<li><p><strong>例 2</strong>：不知道大家小时候查《新华字典》的时候是怎么查的，我经常不翻目录，直接根据要找的字的拼音，在字典里翻页。例如要找的字是「算」（汉语拼音首字母为 S），如果一开始翻到了 L 开头的页，那么我就会在 L 开头的页后面的页里任意挑一页。如果看到的是 T 开头的页，我就会在 T 开头的页前面的页里任意挑一页，这样的查字典的策略就应用了减治思想。</p>
</li>
<li><p><strong>例 3</strong>：相信有不少程序员定位程序中的 bug 的时候，会在程序里打印一些变量的输出语句，逐步定位有问题的代码的行，这样的定位问题的方法也应用了「减治思想」。</p>
</li>
</ul>
<h2 id="二分查找算法的应用范围"><a href="#二分查找算法的应用范围" class="headerlink" title="二分查找算法的应用范围"></a>二分查找算法的应用范围</h2><h3 id="在有序数组中进行查找一个数（二分下标）"><a href="#在有序数组中进行查找一个数（二分下标）" class="headerlink" title="在有序数组中进行查找一个数（二分下标）"></a>在有序数组中进行查找一个数（二分下标）</h3><p>这里「数组」和「有序」是很重要的，我们知道：数组具有 <strong>随机访问</strong> 的特性，由于数组在内存中 <strong>连续存放</strong>，因此我们可以通过数组的下标快速地访问到这个元素。如果数据存放在链表中，访问一个元素我们都得通过遍历，有遍历的功夫我们早就找到了这个元素，因此，在链表中不适合使用二分查找。</p>
<h3 id="在整数范围内查找一个整数（二分答案）"><a href="#在整数范围内查找一个整数（二分答案）" class="headerlink" title="在整数范围内查找一个整数（二分答案）"></a>在整数范围内查找一个整数（二分答案）</h3><p>如果我们要找的是一个整数，并且我们知道这个整数的范围，那么我们就可以使用二分查找算法，逐渐缩小整数的范围。这一点其实也不难理解，假设我们要找的数最小值为 00，最大值为 NN，我们就可以把这个整数想象成数组 [0, 1, 2,…, N] 里的一个值，这个数组的下标和值是一样的，找数组的下标就等于找数组的值。这种二分法用于查找一个有范围的数，也被称为「二分答案」，或者「二分结果」，也就是在「答案区间」里或者是「结果区间」里逐渐缩小目标元素的范围；</p>
<p>在我们做完一些问题以后，我们就会发现，其实二分查找不一定要求目标元素所在的区间是有序数组，也就是说「有序」这个条件可以放宽，半有序数组或者是山脉数组里都可以应用二分查找算法。</p>
<p>旋转数组和山脉数组有什么样的特点呢？可以通过当前元素附近的值推测出当前元素一侧的所有元素的性质，也就是说，旋转和山脉数组的值都有规律可循，元素的值不是随机出现的，在这个特点下，「减治思想」就可以应用在旋转数组和山脉数组里的一些问题上。我们可以把这两类数组统一归纳为部分有序数组。</p>
<h2 id="二分查找算法的两种思路"><a href="#二分查找算法的两种思路" class="headerlink" title="二分查找算法的两种思路"></a>二分查找算法的两种思路</h2><ul>
<li>思路 1：在循环体中查找元素</li>
<li>思路 2：在循环体中排除目标元素一定不存在的区间</li>
</ul>
<h2 id="二分查找的最基本问题"><a href="#二分查找的最基本问题" class="headerlink" title="二分查找的最基本问题"></a>二分查找的最基本问题</h2><p>最基础的二分查找的问题就是在一个有序数组中查找目标元素</p>
<h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == target)   <span class="keyword">return</span> m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[m] &lt; target)   l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p><img src="https://i.loli.net/2020/11/19/cOVdNHZfj7thqLS.png" alt="1605065500626.png"><br>在这一节内容的一开始，我们先来看一下，「力扣」第 704 题另外两种「二分查找」的写法，事实上这两种写法在思想上是一样的。</p>
<h4 id="代码块1"><a href="#代码块1" class="headerlink" title="代码块1"></a>代码块1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target)   l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="代码块2"><a href="#代码块2" class="headerlink" title="代码块2"></a>代码块2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &gt; target)   r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们看一下，这两种写法和思路 1 的写法有何不同。</p>
<p>循环可以继续的条件是 while (left &lt; right) ，这是一个很重要的标志。为什么是严格小于呢？我们上一节说过，当 left == right ，左边界和右边界重合的时候，区间里只有 1 个元素时候，二分查找的逻辑还需要继续下去；而现在大家看到的这个解法在 left == right 重合的时候就退出了循环，这一点表示区间里只剩下一个元素的时候，有可能这个元素就是我们要找的那个元素。这一点与二分查找算法的思路 2（在循环体中排除元素）是一致的：排除了所有错误的答案，如果题目告诉我们只有 11 个目标元素，那么剩下的这个元素就一定是目标元素。<br>在退出循环以后，还需要单独做一次判断；那么这样的写法是不是更麻烦了呢？其实不是的：</p>
<ul>
<li>首先，有些算法问题根据题目的意思，要找的目标元素一定落在题目给的区间里，那么最后的这一步判断可以省略；</li>
<li>并且我们看到这个写法只把区间分成了两个部分，其实在我们编写代码的时候要考虑的因素会更少。这两个区间没有交集，并且它们合起来组成了整个当前待搜索的区间。因此，在思考缩小待搜索区间的逻辑的时候，只需要考虑其中一种情况，另一种情况得到的区间就正好是上一个区间的反面区间；</li>
<li>那么如何考虑缩小问题的区间呢？通常的思路是：先思考要找的数的性质，然后对这个性质取反，也就是：先讨论看到的中间位置的元素在什么情况下不是目标元素，采用这样的思路解决问题会容易一些；<blockquote>
<p>友情提示：生活中的一些事情我们往往很清楚自己不需要什么，但是说不清楚自己真正需要什么。从中间位置的元素在什么情况下不是目标元素考虑，使得问题变得简单也是类似的事实。</p>
</blockquote>
</li>
</ul>
<h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li>如果这个二分查找的问题比较简单，在输入数组里不同元素的个数只有 1 个，使用思路 1 ，在循环体内查找这个元素；</li>
<li>如果这个二分查找的问题比较复杂，要你找一个可能在数组里不存在，或者是找边界这样的问题，使用思路 2 ，在循环体内排除一定不存在目标元素的区间会更简单一些。<h2 id="二分查找的细节（重点）"><a href="#二分查找的细节（重点）" class="headerlink" title="二分查找的细节（重点）"></a>二分查找的细节（重点）</h2><h3 id="细节-1：循环可以继续的条件"><a href="#细节-1：循环可以继续的条件" class="headerlink" title="细节 1：循环可以继续的条件"></a>细节 1：循环可以继续的条件</h3>while (left &lt;= right) 表示在区间里只剩下一个元素的时候，我们还需要继续查找，因此循环可以继续的条件是 left &lt;= right，这一行代码对应了二分查找算法的思路 1：在循环体中查找元素。<h3 id="细节-2：取中间数的代码"><a href="#细节-2：取中间数的代码" class="headerlink" title="细节 2：取中间数的代码"></a>细节 2：取中间数的代码</h3>取中间数的代码 int mid = (left + right) / 2; ，严格意义上是有 bug 的，这是因为在 left 和 right 很大的时候，left + right 有可能会发生整型溢出，这个时候推荐的写法是：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="细节-3：取中间数可不可以上取整"><a href="#细节-3：取中间数可不可以上取整" class="headerlink" title="细节 3：取中间数可不可以上取整"></a>细节 3：取中间数可不可以上取整</h3>我们在「细节 2」里介绍了 int mid = (left + right) / 2; 这个表达示里 / 2 这个除号表示的含义是下取整。很显然，在区间里有偶数个元素的时候位于中间的数有 22 个，这个表达式只能取到位于左边的那个数。一个很自然的想法是，可不可以取右边呢？<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="编码要点"><a href="#编码要点" class="headerlink" title="编码要点"></a>编码要点</h2></li>
<li>循环终止条件写成：while (left &lt; right) ，表示退出循环的时候只剩下一个元素；</li>
<li>在循环体内考虑如何缩减待搜索区间，也可以认为是在待搜索区间里排除一定不存在目标元素的区间；</li>
<li>根据中间数被分到左边和右边区间，来调整取中间数的行为；</li>
<li>如何缩小待搜索区间，一个有效的办法是：从 nums[mid] 满足什么条件的时候一定不是目标元素去考虑，进而考虑 mid 的左边元素和右边元素哪一边可能存在目标元素。一个结论是：当看到 left = mid 的时候，取中间数需要上取整，这一点是为了避免死循环；</li>
<li>退出循环的时候，根据题意看是否需要单独判断最后剩下的那个数是不是目标元素。</li>
</ul>
<p>边界设置的两种写法：</p>
<ul>
<li>right = mid 和 left = mid + 1 和 int mid = left + (right - left) / 2; 一定是配对出现的；</li>
<li>right = mid - 1 和 left = mid 和 int mid = left + (right - left + 1) / 2; 一定是配对出现的。</li>
</ul>
<h2 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h2><p>###<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34题</a>：<br><img src="https://i.loli.net/2020/11/19/yUiKqdtL39fkPn6.png" alt="16051815148![1605751095213.png](https://i.loli.net/2020/11/19/jhxWq4BkoucfSAG.png).png"></p>
<p>这道题主要利用思路2来排除不符合的区间，通过两个函数分别找到左右端。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())    <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l = searchLeft(nums, target);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">-1</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;<span class="comment">//一个编码小细节，如果找不到左端说明这个数不存在可直接返回</span></span><br><span class="line">        <span class="keyword">int</span> r = searchRight(nums, target);</span><br><span class="line">        <span class="keyword">return</span> &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchLeft</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target)    l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchRight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &gt; target)    r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="35题"><a href="#35题" class="headerlink" title="35题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-insert-position/">35题</a></h3><p><img src="https://i.loli.net/2020/11/19/M2lEZLSUdXBC7v5.png" alt="1605182078678.png"><br>这道题非常简单，还是思路2排除比target小的区间即可（注意特殊情况当target大于数组最大值）</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(!n)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; nums[n<span class="number">-1</span>])  <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target)    l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="36题"><a href="#36题" class="headerlink" title="36题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">36题</a></h3><p><img src="https://i.loli.net/2020/11/19/YUBJz9Lf8Tokiwe.png" alt="1605512459012.png"><br>这道题所给的数组并不是一个严格意义上的排序数组，它是在排序数组的基础上进行了部分旋转。<br>我们可以根据旋转后数组的中间数和左右端的数进行比较，从而确定最小值处在左边还是右边。</p>
<ul>
<li>nums[mid] &gt; nums[left], nums[right] &gt; nums[mid]. 这种情况属于未进行旋转的原始排序数组。最小值位于左半边，收缩右边界。</li>
<li>nums[mid] &gt; nums[left], nums[right] &lt; nums[mid]  最小值位于右半边，收缩左边界。</li>
<li>nums[mid] &lt; nums[left], nums[right] &gt; nums[mid]  这种单调递减的情况不存在。</li>
<li>nums[mid] &lt; nums[left], nums[right] &lt; nums[mid]  最小值位于左半边，收缩右边界。<br>根据以上分析，我们可以看到判断收缩左边界还是右边界可以利用中间值和最右值的大小比较。<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; nums[r])&#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="154题"><a href="#154题" class="headerlink" title="154题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154题</a></h3><img src="https://i.loli.net/2020/11/19/U9fx1mEdHV5wYOt.png" alt="1605513997240.png"><br>这道题在上一道题的基础上引入了可重复这一条件。因此在比较中间值和最右值的大小时，有可能出现相等的情况。在这种情况下，最小值既可能出现在左半边也可能出现在右半边。倘若最右值即是最小值，那么因为中间值和最右值不是同一个位置，因此在中间到最右这个区间内均为最小值，此时我们可以收缩右边界一个单位。最右值如果不是最小值，那可以直接收缩右边界一个单位。<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; nums[r])   r = m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[m] &gt; nums[r])  l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="69题"><a href="#69题" class="headerlink" title="69题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/">69题</a></h3><img src="https://i.loli.net/2020/11/19/3KdiIBcJyzlDCRX.png" alt="1605749379248.png"><br>这道题就是一个很基础的实现sqrt()函数的内容。<br>我们知道任何一个自然数的平方根都不可能大于其一半，因此右边界可以从该数的一半开始。<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x / <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//针对特殊情况1</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">long</span> m = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//防止数过大超过整型</span></span><br><span class="line">            <span class="keyword">long</span> tmp = m * m;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; x) r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="287题"><a href="#287题" class="headerlink" title="287题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287题</a></h3><img src="https://i.loli.net/2020/11/19/jhxWq4BkoucfSAG.png" alt="1605751095213.png"><br>这道题可以用二分法我是没想到的，看了weiwei哥的题解后感到十分惊艳。我们用二分法时，要注意思考我们二分什么内容，找到了这个关键点，题目也就水落石出了，当然这个key得根据题意来判断。<br>这道题我们可以通过找小于等于中间值的个数来判断收缩哪个区间。<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= m)    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; m) r = m;</span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ivan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://ivan-07.xyz/2020/11/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">http://ivan-07.xyz/2020/11/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Ivan-07.xyz">Ivan</a>！</span></div></div><div class="post-meta__tag-list"></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/alipay.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/11/29/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/"><i class="fa fa-chevron-left">  </i><span>堆与堆排序</span></a></div><div class="next-post pull-right"><a href="/2020/10/25/49_Group%20Anagrams/"><span>Group Anagrams</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=19711382&auto=1&height=66"></iframe></div><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'WiWGXN6levReCU00TgaH199a-MdYXbMMI',
  appKey:'KPXrGy6xcuX8Y2H09SelXcjS',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(/img/top_img.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By Ivan</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://ivan-07.xyz">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script src="/js/search/algolia.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>